<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YOLO11n TFJS - Camera </title>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    video, canvas { background:#111; border-radius:10px; }
    button { padding:10px 12px; cursor:pointer; margin-right:8px; margin-bottom:8px; }
    pre { background:#f6f6f6; padding:12px; border-radius:10px; overflow:auto; width:520px; height:420px; }
    .stat { margin: 8px 0 12px; padding: 10px; background: #f6f6f6; border-radius: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>

<h2>YOLO11n TFJS - Kamera Analizi</h2>

<div class="row">
  <div>
    <video id="video" autoplay playsinline muted></video>
    <div style="height:8px"></div>
    <canvas id="canvas"></canvas>
  </div>

  <div>
    <div>
      <button id="btnCam">Kamerayı Başlat</button>
      <button id="btnModel">Modeli Yükle</button>
      <button id="btnRun">Analizi Başlat</button>
      <button id="btnStop">Durdur</button>
    </div>

    <div class="stat">
      <div><b>Durum</b></div>
      <div id="status" class="mono">Hazır</div>
      <div style="height:6px"></div>
      <div><b>Son tahmin</b></div>
      <div id="pred" class="mono">-</div>
    </div>

    <pre id="log" class="mono"></pre>
  </div>
</div>

<script>
/* =======================
   CONFIG
======================= */
const MODEL_URL = './yolo11n/model.json';
const MODEL_SIZE = 640;

// Bu modelde obj yok, skor = max class score
const CONF_TH = 0.25;
const IOU_TH = 0.45;
const MAX_DET = 50;

// COCO80 (custom ise değiştir)
const COCO80 = [
  "person","bicycle","car","motorcycle","airplane","bus","train","truck","boat","traffic light",
  "fire hydrant","stop sign","parking meter","bench","bird","cat","dog","horse","sheep","cow",
  "elephant","bear","zebra","giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee",
  "skis","snowboard","sports ball","kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket",
  "bottle","wine glass","cup","fork","knife","spoon","bowl","banana","apple","sandwich","orange",
  "broccoli","carrot","hot dog","pizza","donut","cake","chair","couch","potted plant","bed",
  "dining table","toilet","tv","laptop","mouse","remote","keyboard","cell phone","microwave","oven",
  "toaster","sink","refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"
];

/* =======================
   UI / STATE
======================= */
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
canvas.style.display= "none";
const ctx = canvas.getContext('2d');

const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const predEl = document.getElementById('pred');

let model = null;
let running = false;
let rafId = null;

function setStatus(s) { statusEl.textContent = s; }
function setPred(s) { predEl.textContent = s; }

function log(...args) {
  const s = args.map(a => (typeof a === 'string' ? a : JSON.stringify(a, null, 2))).join(' ');
  logEl.textContent = s + "\n" + logEl.textContent;
  console.log(...args);
}

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

/* =======================
   CAMERA
======================= */
async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  canvas.width = video.videoWidth || 640;
  canvas.height = video.videoHeight || 480;

  setStatus(`Kamera hazır (${canvas.width}x${canvas.height})`);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  log("Kamera:", canvas.width, "x", canvas.height);
}

/* =======================
   MODEL
======================= */
async function loadModel() {
  setStatus("TFJS hazırlanıyor...");
  await tf.setBackend('webgl');
  await tf.ready();
  log("TFJS backend:", tf.getBackend());

  setStatus("Model yükleniyor...");
  model = await tf.loadGraphModel(MODEL_URL);
  setStatus("Model yüklendi");
  log("Model yüklendi:", MODEL_URL);

  // Output shape doğrulama
  const dummy = tf.zeros([1, MODEL_SIZE, MODEL_SIZE, 3]);
  const out = await model.executeAsync(dummy);
  dummy.dispose();

  if (Array.isArray(out)) {
    log("Output tensor sayısı:", out.length);
    out.forEach((t, i) => log(`out[${i}] shape:`, t.shape, "dtype:", t.dtype));
    out.forEach(t => t.dispose());
  } else {
    log("Output shape:", out.shape, "dtype:", out.dtype);
    out.dispose();
  }
}

/* =======================
   PREPROCESS (LETTERBOX)
======================= */
function preprocessLetterbox() {
  return tf.tidy(() => {
    const img = tf.browser.fromPixels(video); // [h,w,3]
    const [h, w] = img.shape.slice(0, 2);

    const scale = Math.min(MODEL_SIZE / w, MODEL_SIZE / h);
    const newW = Math.round(w * scale);
    const newH = Math.round(h * scale);

    const resized = tf.image.resizeBilinear(img, [newH, newW]);

    const padX = MODEL_SIZE - newW;
    const padY = MODEL_SIZE - newH;

    const left = Math.floor(padX / 2);
    const right = padX - left;
    const top = Math.floor(padY / 2);
    const bottom = padY - top;

    const padded = tf.pad(resized, [[top, bottom], [left, right], [0, 0]]);
    const input = padded.toFloat().div(255.0).expandDims(0);

    const meta = { w, h, scale, left, top };
    return { input, meta };
  });
}

/* =======================
   OUTPUT -> [N,D]
   Given out: [1,84,8400]
======================= */
function toPred2D(outTensor) {
  return tf.tidy(() => {
    let t = outTensor;

    // [1,84,8400] -> [84,8400]
    if (t.shape.length === 3 && t.shape[0] === 1) {
      t = t.squeeze([0]);
    }

    // Eğer [D,N] ise -> [N,D]
    if (t.shape.length === 2) {
      const [a, b] = t.shape; // a=84, b=8400
      const looksLikeD = (x) => x >= 6 && x <= 300;
      const looksLikeN = (x) => x >= 500;

      if (looksLikeD(a) && looksLikeN(b)) {
        t = t.transpose(); // [8400,84]
      }
    }

    return t; // [N,D]
  });
}

/* =======================
   DECODE + NMS (84 head)
   row: [x,y,w,h, cls0..cls79]
   score = max(cls)
======================= */
async function decodeAndNms84(pred2d, meta) {
  const pred = await pred2d.array(); // [N][84]
  if (!pred.length) return [];

  const D = pred[0].length; // 84
  const nc = D - 4;         // 80

  const { w: origW, h: origH, scale, left, top } = meta;

  // Koordinatlar normalize mi? (sende örnekler 3..11, yani pixel/640)
  let sampleMax = 0;
  for (let i = 0; i < Math.min(pred.length, 200); i++) {
    const r = pred[i];
    sampleMax = Math.max(sampleMax, r[0], r[1], r[2], r[3]);
  }
  const isNormalized = sampleMax <= 2.0;

  const boxes = [];
  const scores = [];
  const classIds = [];

  for (let i = 0; i < pred.length; i++) {
    const r = pred[i];

    let x = r[0], y = r[1], bw = r[2], bh = r[3];

    // class max (col4..col83)
    let best = -1;
    let bestId = -1;
    for (let c = 0; c < nc; c++) {
      const v = r[4 + c];
      if (v > best) { best = v; bestId = c; }
    }

    const score = best; // obj yok -> skor = max class
    if (score < CONF_TH) continue;

    // model input space (640x640)
    const mx = isNormalized ? x * MODEL_SIZE : x;
    const my = isNormalized ? y * MODEL_SIZE : y;
    const mw = isNormalized ? bw * MODEL_SIZE : bw;
    const mh = isNormalized ? bh * MODEL_SIZE : bh;

    // center->corners (model input space)
    const x1m = mx - mw / 2;
    const y1m = my - mh / 2;
    const x2m = mx + mw / 2;
    const y2m = my + mh / 2;

    // letterbox geri map: pad çıkar, scale böl
    const x1 = (x1m - left) / scale;
    const y1 = (y1m - top) / scale;
    const x2 = (x2m - left) / scale;
    const y2 = (y2m - top) / scale;

    // clamp
    const xx1 = clamp(x1, 0, origW);
    const yy1 = clamp(y1, 0, origH);
    const xx2 = clamp(x2, 0, origW);
    const yy2 = clamp(y2, 0, origH);

    const ww = xx2 - xx1;
    const hh = yy2 - yy1;
    if (ww <= 1 || hh <= 1) continue;

    boxes.push([yy1, xx1, yy2, xx2]);
    scores.push(score);
    classIds.push(bestId);
  }

  if (!boxes.length) return [];

  const idx = await tf.image.nonMaxSuppressionAsync(
    boxes, scores, MAX_DET, IOU_TH, CONF_TH
  );
  const keep = await idx.array();
  idx.dispose();

  return keep.map(i => ({ box: boxes[i], score: scores[i], classId: classIds[i] }));
}

/* =======================
   DRAW
======================= */
function drawDetections(dets) {
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  ctx.lineWidth = 2;
  ctx.font = "16px system-ui";
  ctx.textBaseline = "top";

  for (const d of dets) {
    const [y1, x1, y2, x2] = d.box;

    const xx1 = clamp(x1, 0, canvas.width);
    const yy1 = clamp(y1, 0, canvas.height);
    const xx2 = clamp(x2, 0, canvas.width);
    const yy2 = clamp(y2, 0, canvas.height);

    const w = Math.max(0, xx2 - xx1);
    const h = Math.max(0, yy2 - yy1);

    ctx.strokeStyle = "red";
    ctx.strokeRect(xx1, yy1, w, h);

    const name = COCO80[d.classId] ?? `cls_${d.classId}`;
    ctx.fillStyle = "red";
    ctx.fillText(`${name} ${(d.score * 100).toFixed(1)}%`, xx1, yy1);
  }
}

/* =======================
   LOOP
======================= */
async function loop() {
  if (!running) return;
  if (!model) { setStatus("Model yok. Önce modeli yükle."); running = false; return; }

  try {
    const { input, meta } = preprocessLetterbox();
    const out = await model.executeAsync(input);
    input.dispose();

    const outTensor = Array.isArray(out) ? out[0] : out;

    // [1,84,8400] -> [8400,84]
    const pred2d = toPred2D(outTensor);

    const dets = await decodeAndNms84(pred2d, meta);

    pred2d.dispose();
    if (Array.isArray(out)) out.forEach(t => t.dispose());
    else out.dispose();

    // UI
    if (dets.length) {
      const top = dets.slice().sort((a, b) => b.score - a.score)[0];
      const name = COCO80[top.classId] ?? `cls_${top.classId}`;
      setPred(`Detections: ${dets.length} | Top: ${name} ${(top.score * 100).toFixed(1)}%`);
    } else {
      setPred("Detections: 0");
    }

    drawDetections(dets);
    setStatus("Çalışıyor");
  } catch (e) {
    setStatus("Hata");
    log("Inference hatası:", String(e));
    running = false;
    return;
  }

  rafId = requestAnimationFrame(loop);
}

function startRun() {
  if (running) return;
  video.style.display = "none";
  canvas.style.display = "flex";
  running = true;
  setStatus("Başlatıldı");
  log("Analiz başlatıldı.");
  loop();
}

function stopRun() {
  running = false;
  video.style.display = "flex";
  canvas.style.display = "none";
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  setStatus("Durduruldu");
  log("Analiz durduruldu.");
}

/* =======================
   BUTTONS
======================= */
document.getElementById('btnCam').addEventListener('click', () => startCamera().catch(e => log("Cam err:", String(e))));
document.getElementById('btnModel').addEventListener('click', () => loadModel().catch(e => log("Model err:", String(e))));
document.getElementById('btnRun').addEventListener('click', startRun);
document.getElementById('btnStop').addEventListener('click', stopRun);
</script>

</body>
</html>

